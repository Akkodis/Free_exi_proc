//Requires exi.events.ceps

label __8_EXI_Grammars title="8. EXI Grammars";

comment{

"EXI is a knowledge based encoding that uses a set of grammars to determine which events are most likely to occur at any\n";
"given point in an EXI stream and encodes the most likely alternatives in fewer bits. It does this by mapping the stream\n";
"of events to a lower entropy set of reptresentative values and encoding those values using a set of simple variable length\n";
"codes or an EXI compression algorithm.\n\n\n";

"The result is a very simple, small algorithm that uniformly handles schema-less encoding, schema-informed encoding,\n";
"schema deviations, and any combination thereof in EXI streams. These variations do not require different algorithms or different parsers,\n";
"they are simply informed by different combinations of grammars.\n\n\n";

"The following sections describe the grammars used to inform the EXI encoding.\n\n\n";

"Note:\n\n\n";

"The grammar semantics in this specification are written for clarity and generality. They do not prescribe a particular implementation approach.\n";

};

label __8__1_Grammar_Notation title="8.1 Grammar Notation";
label __8__1__1_Fixed_Event_Codes title="8.1.1 Fixed Event Codes";

comment{

"\n\n";
"Each grammar production has an event code, which is represented by a sequence of one to three parts separated by periods (".") [in this ceps specification we use commas (",") instead].\n";
"Each part is an unsigned integer. The following are examples of grammar productions with event codes as theyx appear in this specification.\n";
"\n\n";

};


example{
    label __8__1_Example_productions_fixed_codes title="Example 8-1. Example productions with fixed event codes.";
    GrammarNonterminal LeftHandSide_1;
    GrammarNonterminal LeftHandside_2;
    GrammarTerminal Terminal_1;
    GrammarTerminal Terminal_2;
    GrammarTerminal Terminal_3;
    GrammarTerminal Terminal_4;
    GrammarTerminal Terminal_5;
    GrammarTerminal Terminal_6;
    GrammarAnnotation EventCode;

    Grammar{
            lhs{LeftHandSide_1;};
                rhs{Terminal_1; NonTerminal_1;EventCode(0); };
                rhs{Terminal_2; NonTerminal_2;EventCode(1); };
                rhs{Terminal_3; NonTerminal_3;EventCode(2,0); };
                rhs{Terminal_4; NonTerminal_4;EventCode(2,1); };
                rhs{Terminal_5; NonTerminal_5;EventCode(2,2,0); };
                rhs{Terminal_6; NonTerminal_6;EventCode(2,2,1); };
            lhs{LeftHandSide_2;};
                rhs{Terminal_1; NonTerminal_1;EventCode(0); };
                rhs{Terminal_2; NonTerminal_2;EventCode(1,0); };
                rhs{Terminal_3; NonTerminal_3;EventCode(1,1); };
    };
};

comment{
"\n\n";
"The number of parts in a given event code is called the event code's length.\n";
"No two productions with the same nonterminal Symbolson the left-hand side are permitted to have the same event code.\n\n\n";

};

label __8__1__2_Variable_Event_Codes title="8.1.2 Variable Event Codes";

comment{

"Some non-terminal symbols are used on the right-hand side in a production without a terminal symbol prefixed to them,\n";
"but with a parenthesized event code affixed instead. Such non-terminal symbols are macros amd they are used to capture some recurring\n";
"set of productions as symbols so that a symbol can be used in the grammar representation instead of including all the productions the macro\n\n\n";
"represents in place every time it is used.\n\n";  

};

example{
    label __8__2_Example_productions_using_macros title="Example 8-2. Example productions that use macro non-terminal symbols.";
    GrammarNonterminal ABigProduction_1;
    GrammarNonterminal ABigProduction_2;
    GrammarNonterminal NonTerminal_1;
    GrammarNonterminal NonTerminal_2;
    GrammarTerminal Terminal_1;
    GrammarTerminal Terminal_2;
    Grammar{
        lhs{ABigProduction_1;};
            rhs{Terminal_1; NonTerminal_1;EventCode(0);};
            LEFTHANDSIDE{2;0;};
        lhs{ABigProduction_2;};
            rhs{Terminal_1; NonTerminal_1;};
            LEFTHANDSIDE{1;1;};
            rhs{Terminal_2; NonTerminal_2;};
    }; 
};

comment{

"Because non-terminal macros are injected into the right-hand side of more than one production, the event codes of\n";
"productions with these macro non-terminals on the left-hand side are not fixed, but will have different event code values depending\n";
"on the context in which the macro non-terminal appears. This specification calls these variable event codes and use variables in place\n";
"of individual event code parts to indicate the event code parts are determined by the context. Below are some examples of variable event codes.\n\n\n";

};

macro LEFTHANDSIDE{
 GrammarNonterminal NONTERMINAL_1,NONTERMINAL_2,NONTERMINAL_3,NONTERMINAL_4,NONTERMINAL_5,NONTERMINAL_6;
 GrammarTerminal TERMINAL_1, TERMINAL_2, TERMINAL_3, TEMINAL_4, TERMINAL_5, TERMINAL_6;

 val i = hd(arglist);
 val j = hd(tail(arglist));
 rhs{TERMINAL_1; NONTERMINAL_1; EventCode(i,0);};
 rhs{TERMINAL_2; NONTERMINAL_2; EventCode(i,1);};
 rhs{TERMINAL_3; NONTERMINAL_3; EventCode(i,j+2);};
 rhs{TERMINAL_4; NONTERMINAL_4; EventCode(i,j+3);};
 rhs{TERMINAL_5; NONTERMINAL_5; EventCode(i,j+4,0);};
 rhs{TERMINAL_6; NONTERMINAL_6; EventCode(i,j+4,1);};
};

comment{
    
"Unless otherwise specified, the variable i evaluates to the first part of the event code of the production in which the macro non-terminal LeftHandSide_1\n";
"appears on the right-hand side. Similarly, the expression i.j represents the first two parts of the event code of the production in which\n";
"the macro LEFTHANDSIDE_1 appears on the right-hand side.\n\n\n";

"Non-terminal macros are used in this specification for notational convenience only. They are non-terminals, even though they are used in place of non-terminals.\n";
"Productions that use non-terminal macros on the right-hand side need to be expanded by macro substitution before such productions are interpreted. Therefore, ABigProduction_1\n";
"and ABigProduction_2 shown in the preceding example are quivalen to the following set of productions obtained by expanding the non-terminal maro symbol LEFTHANDSIDE_1 and\n";
"evaluating the variable event codes.\n\n\n";

};

example{
    label __8__2_Expanded_productions_equivalent_to_the_productions_used_above title="8.2 Expanded productions equivalent to the productions used above.";
};

label __8__2_Grammar_Event_Codes title="8.2 Grammar Event Codes";

comment{

"Each production rule in the EXI grammar includes an event code value that approximates the likelihood the associated production rule will be matched over the other\n";
"productions with the same left-hand-side non-terminal symbol. Ultimately, the event codes determine the value(s) by which each non-terminal symbol will be\n";
"represented in the EXI stream.\n\n\n";

"To understand how a given event code approximates the likelihood a given production will match, it is useful to visualize the event codes for a set of production rules that have\n";
"the same non-terminal symbol on the left-hand side as a tree.\n";
"For example, the following set of productions:\n\n";

};

Grammar{
    GrammarNonterminal ElementContent;
    GrammarAnnotation EventCode;
    lhs{ElementContent;};
        rhs{EE;EventCode(0);};
        rhs{SE(_*_); ElementContent;EventCode(1,0);};
        rhs{CH;ElementContent;EventCode(1,1);};
        rhs{ER;ElementContent;EventCode(1,2);};
        rhs{CM;ElementContent;EventCode(1,3,0);};
        rhs{PI;Elementcontent;EventCode(1,3,2);};
};

comment{

"\n\nrepresents a set of informationm items that might occur as element content after the start tag. Using the production event codes, we can visualize this set of productions as follows:\n\n";

};

figure{
    Tree(
        Leaf(EE,0),
        Tree(
            Leaf(SE(_*_),0),
            Leaf(CH,1),
            Leaf(ER,2),
            Tree(
                Leaf(CM,0),
                Leaf(PI,1),
                3
            )            
            , 1)
    );
    caption{"Event code tree for ElementContent grammar";};
};

comment{

"where the terminal symbols are represented by the leaf nodes of the tree, and the event code of each production rule defines a path from the root of the tree\n";
"to the node that represents the terminal symbol that is on the right-hand side of the production. We call this the event code tree for a given set of productions.\n\n\n";

"An event code tree is similar to a Huffman tree in that shorter paths are generally used for symbols that are considered more likely. However, event code\n";
"trees are far simpler and less costly to compute and maintain. Event code trees are shallow and contain at most three levels. In addition, the length of ech event code\n";
"in the event code tree is assigned statically without analyzing the data. This classification provides some of the benefits of a Huffman tree without the cost.\n\n\n";

};



label __8__3_Pruning title="8.3 Pruning Unneeded Productions";


comment{

"As discussed in section [6.3 Fidelity Options], applications MAY provide a set of fidelity options to specify the XML features they require.\n"; 
"EXI processors MUST use thesefidelity options to prune the productions of which the terminal symbols represent the events that are not required from the grammars,\n";
"improving compactness and processing efficiency. For example, the following set of productions represent the set of information items that might occur as element\n";
"content after the start tag.\n\n\n";

};

example{
    label __8__6_Example_Fidelity title="Example 8-6. Example productions with full fidelity";
    Grammar{
        GrammarNonterminal ElementContent;
        lhs{ElementContent;};
            rhs{EE;ElementContent;EventCode(0);};
            rhs{SE(_*_);ElementContent;EventCode(1,0);};
            rhs{CH;ElementContent;EventCode(1,1);};
            rhs{ER;ElementContent;EventCode(1,2);};
            rhs{CM;ElementContent;EventCode(1,3,0);};
            rhs{PI;ElementContent;EventCode(1,3,1);};
    };
};

exi_prune(
    rhs{ER;ElementContent;}, 
    rhs{CM;ElementContent;}, 
    rhs{PI;ElementContent;},
    Grammar{
        GrammarNonterminal ElementContent;
        lhs{ElementContent;};
            rhs{EE;ElementContent;EventCode(0);};
            rhs{SE(_*_);ElementContent;EventCode(1,0);};
            rhs{CH;ElementContent;EventCode(1,1);};
            rhs{ER;ElementContent;EventCode(1,2);};
            rhs{CM;ElementContent;EventCode(1,3,0);};
            rhs{PI;ElementContent;EventCode(1,3,1);};
    }
);

expect_equality{
    GrammarNonterminal ElementContent;

exi_prune(
    args{ // Embarrassing error in ceps' grammar
        3; 
        rhs{CM;ElementContent;}; 
        rhs{PI;ElementContent;};
        Grammar{
            lhs{ElementContent;};
                rhs{EE;ElementContent;EventCode(0);};
                rhs{SE(_*_);ElementContent;EventCode(1,0);};
                rhs{CH;ElementContent;EventCode(1,1);};
                rhs{ER;ElementContent;EventCode(1,2);};
                rhs{CM;ElementContent;EventCode(1,3,0);};
                rhs{PI;ElementContent;EventCode(1,3,1);};
        };
    }
);


Grammar{
        GrammarNonterminal ElementCount;
        lhs{ElementCount;};
            rhs{EE;ElementCount;EventCode(0);};
            rhs{SE(_*_);ElementCount;EventCode(1,0);};
            rhs{CH;ElementCount;EventCode(1,1);};
};
};


comment{

"If an application sets the fidelity options Preserve.Comments, Preserve.pis and Preserve.dtd to false, the productionsmatching comment (CM),\n"; 
"processing instruction (PI) and entity reference (ER) events are pruned frm the grammar, producing the following set of productions:\n\n\n";

};

example{
    label __8__7_Example_Fidelity_After_Pruning title="Example 8-7. Example productions after pruning";
    Grammar{
        GrammarNonterminal ElementCount;
        lhs{ElementCount;};
            rhs{EE;ElementCount;EventCode(0);};
            rhs{SE(_*_);ElementCount;EventCode(1,0);};
            rhs{CH;ElementCount;EventCode(1,1);};
    };
};

comment{

"Removing these productions from the grammar tells EXI processors that comments and processing instructions will never occur in the EXI stream,\n"; 
"which reduces the entropy of the stream allowing it to be encoded in fewer bits.\n\n\n";

"Each time a production is removed from a grammar, the event codes of the other productions with the same nonterminal symbol on the left-hand side MUST be\n";
"adjusted to keep them contguous if its removal has left the remaining productions with non-contiguous event codes.\n\n\n";

};
    
label __8__4_Built_in_Grammars title="8.4 Built-in XML Grammars";


comment{

"This section describes built-in XML grammars used by EXI when no schema information is available or when available schema information describes \
only portions of the EXI stream.\n\n"; 

"The built-in XML grammars are dynamic and continuously evolve to reflect knowledge learned while processing an EXI stream. \
New built-in element grammars are created to describe the content of newly encountered elements and new grammar productions are added \
to refine existing built-in grammars. Newly learned grammars and productions are used to more efficiently represent subsequent events in the EXI stream. \
All newly created built-in element grammars are global element grammars.\n\n";

"[Definition:] A global element grammar is a grammar describing the content of an element that has global scope (i.e. a global element). \
At the onset of processing an EXI stream, the set of global element grammars is the set of all schema-informed element grammars derived from element declarations \
that have a {scope} property of global. Each built-in element grammar created while processing an EXI stream is added to the set of global element grammars. \
Each global element grammar has a unique qname.\n\n";

};

label __8__4__1__Built_in_Document_Grammar title="8.4.1 Built-in Document Grammar";

comment{
"In the absence of schema information describing the content of the EXI stream, the following grammar describes the events that will occur in an EXI document.\n\n";
};

Grammar{
    GrammarNonterminal Document, DocContent, DocEnd;
        lhs{Document;};
            rhs{SD; DocContent; EventCode(0);};
        lhs{DocContent;};
            rhs{SE(_*_); DocEnd; EventCode(0);};
            rhs{DT; DocContent; EventCode(1,0);};
            rhs{CM; DocContent; EventCode(1,1,0);};
            rhs{PI;DocContent; eventCode(1,1,1);};
        lhs{DocEnd;};
            rhs{ED; EventCode(0);};
            rhs{CM; DocEnd; EventCode(1,0);};
            rhs{PI; DocEnd; EventCode(1,1);};
};


comment{
"\n"; Semantics; "\n";
"All productions in the built-in document grammars from "; LeftHandSide; " : "; SE(_*_);" "; RightHandSide;
" are evaluated as follows:\n\n";
"1. Let "; qname; " be the "; qname; " of the element matched by "; SE(_*_); " i.e "; qname == _*_ ; " \n";
"2. If a global element grammar does not exist for element ";qname;", create one according to section 8.4.3. Built-in Element Grammar."; " \n";
"3. Evaluate the element content using the global element grammar for element ";qname; " \n";
"4. Evaluate the remainder of event sequence using "; RightHandSide; " \n";
"\n\n";
};


label __8__4__2__Built_in_Fragment_Grammar title="8.4.2 Built-in Fragment Grammar";

comment{

"In the absence of schema information describing the contents of an EXI stream, the following grammar describes the events that may occur\n";
"in an EXI fragment. The grammar below represents the initial set of productions in the built-in fragment grammar at the start of EXI stream\n"; 
"processing. The associated semantics explain how the built-in fragment grammar evolves to more efficiently represent subsequent events in the EXI stream.\n\n\n";  

};

Grammar{
    GrammarNonterminal Fragment, FragmentContent;
    lhs{Fragment;};
        rhs{SD; FragmentContent; EventCode(0);};
    lhs{FragmentContent;};
        rhs{SE(_*_); FragmentContent; EventCode(0); };
        rhs{ED; EventCode(1);};
        rhs{CM; FragmentContent; EventCode(2,0);};
        rhs{PI; FragmentContent; EventCode(2,1);};
};
comment{

"\n\n";
"Semantics:\n";
"\n\n";"\n\n";
"All productions in the built-in fragment grammars of the form LeftHandSide: ";SE(_*_);" RightHandSide are evaluated as folows:\n";
"\n\n";
"1. Let qname be the qname of the element matched by ";SE(_*_);" \n";
"2. If a global element grammar does not exist for element ";qname;", create one according to section 8.4.3 Built-in Element Grammar.\n";
"3. Create a production of the form LeftHandSide: ";SE(qname);" RightHandSide with event code ";0;".\n";
"4. Increment the first part of the event code of each production in the current grammar with the non-terminal LeftHandSide on the left-hand side.\n";
"5. Add the production created in step 3 to the grammar\n";
"6. Evaluate the element content using the global element grammar for element ";qname;" .\n";
"7. Evaluate the remainder of event sequence using RihgtHandSide.\n";
"\n\n";
"All productions of the form LeftHandSide : ";SE(qname);" RightHandSide that were previously added to the grammar upon the first occurence of the element that\n";
"has ";qname;" qname are evaluated as follows when they are matched.\n";
"\n\n";
"1. Evaluate the element content using the global element grammar for element ";qname;" \n";
"2. Evaluate the remainder of event sequence using RightHandSide.\n";
"\n\n";

};

















