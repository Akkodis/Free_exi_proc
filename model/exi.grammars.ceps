//Requires exi.events.ceps

label __8_EXI_Grammars title="8. EXI Grammars";

/*

EXI is a knowledge based encoding that uses a set of grammars to determine which events are most likely to occur at any
given point in an EXI stream and encodes the most likely alternatives in fewer bits. It does this by mapping the stream
of events to a lower entropy set of reptresentative values and encoding those values using a set of simple variable length 
codes or an EXI compression algorithm.

The result is a very simple, small algorithm that uniformly handles schema-less encoding, schema-informed encoding,
schema deviations, and any combination thereof in EXI streams. These variations do not require different algorithms or different parsers,
they are simply informed by different combinations of grammars.

The following sections describe the grammars used to inform the EXI encoding.

Note:

The grammar semantics in this specification are written for clarity and generality. They do not prescribe a particular implementation approach. 

*/

label __8__1_Grammar_Notation title="8.1 Grammar Notation";
label __8__1__1_Fixed_Event_Codes title="8.1.1 Fixed Event Codes";

/*
Each grammar production has an event code, which is represented by a sequence of one to three parts separated by periods (".") [in this ceps specification we use commas (",") instead].
Each part is an unsigned integer. The following are examples of grammar productions with event codes as theyx appear in this specification.

*/


example{
    label __8__1_Example_productions_fixed_codes title="Example 8-1. Example productions with fixed event codes.";
    GrammarNonterminal LeftHandSide_1;
    GrammarNonterminal LeftHandside_2;
    GrammarTerminal Terminal_1;
    GrammarTerminal Terminal_2;
    GrammarTerminal Terminal_3;
    GrammarTerminal Terminal_4;
    GrammarTerminal Terminal_5;
    GrammarTerminal Terminal_6;
    GrammarAnnotation EventCode;

    Grammar{
            lhs{LeftHandSide_1;};
                rhs{Terminal_1; NonTerminal_1;EventCode(0); };
                rhs{Terminal_2; NonTerminal_2;EventCode(1); };
                rhs{Terminal_3; NonTerminal_3;EventCode(2,0); };
                rhs{Terminal_4; NonTerminal_4;EventCode(2,1); };
                rhs{Terminal_5; NonTerminal_5;EventCode(2,2,0); };
                rhs{Terminal_6; NonTerminal_6;EventCode(2,2,1); };
            lhs{LeftHandSide_2;};
                rhs{Terminal_1; NonTerminal_1;EventCode(0); };
                rhs{Terminal_2; NonTerminal_2;EventCode(1,0); };
                rhs{Terminal_3; NonTerminal_3;EventCode(1,1); };
    };
};

/*
The number of parts in a given event code is called the event code's length. 
No two productions with the same nonterminal Symbolson the left-hand side are permitted to have the same event code.
*/

label __8__1__2_Variable_Event_Codes title="8.1.2 Variable Event Codes";

/*
Some non-terminal symbols are used on the right-hand side in a production without a terminal symbol prefixed to them,
but with a parenthesized event code affixed instead. Such non-terminal symbols are macros amd they are used to capture some recurring
set of productions as symbols so that a symbol can be used in the grammar representation instead of including all the productions the macro
represents in place every time it is used.  
*/

example{
    label __8__2_Example_productions_using_macros title="Example 8-2. Example productions that use macro non-terminal symbols.";
    GrammarNonterminal ABigProduction_1;
    GrammarNonterminal ABigProduction_2;
    GrammarNonterminal NonTerminal_1;
    GrammarNonterminal NonTerminal_2;
    GrammarTerminal Terminal_1;
    GrammarTerminal Terminal_2;
    Grammar{
        lhs{ABigProduction_1;};
            rhs{Terminal_1; NonTerminal_1;EventCode(0);};
            LEFTHANDSIDE{2;0;};
        lhs{ABigProduction_2;};
            rhs{Terminal_1; NonTerminal_1;};
            LEFTHANDSIDE{1;1;};
            rhs{Terminal_2; NonTerminal_2;};
    }; 
};

/*
Because non-terminal macros are injected into the right-hand side of more than one production, the event codes of
productions with these macro non-terminals on the left-hand side are not fixed, but will have different event code values depending
on the context in which the macro non-terminal appears. This specification calls these variable event codes and use variables in place 
of individual event code parts to indicate the event code parts are determined by the context. Below are some examples of variable event codes.

*/

macro LEFTHANDSIDE{
 GrammarNonterminal NONTERMINAL_1,NONTERMINAL_2,NONTERMINAL_3,NONTERMINAL_4,NONTERMINAL_5,NONTERMINAL_6;
 GrammarTerminal TERMINAL_1, TERMINAL_2, TERMINAL_3, TEMINAL_4, TERMINAL_5, TERMINAL_6;

 val i = hd(arglist);
 val j = hd(tail(arglist));
 rhs{TERMINAL_1; NONTERMINAL_1; EventCode(i,0);};
 rhs{TERMINAL_2; NONTERMINAL_2; EventCode(i,1);};
 rhs{TERMINAL_3; NONTERMINAL_3; EventCode(i,j+2);};
 rhs{TERMINAL_4; NONTERMINAL_4; EventCode(i,j+3);};
 rhs{TERMINAL_5; NONTERMINAL_5; EventCode(i,j+4,0);};
 rhs{TERMINAL_6; NONTERMINAL_6; EventCode(i,j+4,1);};
};

/*
Unless otherwise specified, the variable i evaluates to the first part of the event code of the production in which the macro non-terminal LeftHandSide_1
appears on the right-hand side. Similarly, the expression i.j represents the first two parts of the event code of the production in which
the macro LEFTHANDSIDE_1 appears on the right-hand side.

Non-terminal macros are used in this specification for notational convenience only. They are non-terminals, even though they are used in place of non-terminals.
Productions that use non-terminal macros on the right-hand side need to be expanded by macro substitution before such productions are interpreted. Therefore, ABigProduction_1
and ABigProduction_2 shown in the preceding example are quivalen to the following set of productions obtained by expanding the non-terminal maro symbol LEFTHANDSIDE_1 and
evaluating the variable event codes.
*/

example{
    label __8__2_Expanded_productions_equivalent_to_the_productions_used_above title="8.2 Expanded productions equivalent to the productions used above.";
};

label __8__2_Grammar_Event_Codes title="8.2 Grammar Event Codes";

/*
Each production rule in the EXI grammar includes an event code value that approximates the likelihood the associated production rule will be matched over the other
productions with the same left-hand-side non-terminal symbol. Ultimately, the event codes determine the value(s) by which each non-terminal symbol will be 
represented in the EXI stream.

To understand how a given event code approximates the likelihood a given production will match, it is useful to visualize the event codes for a set of production rules that have
the same non-terminal symbol on the left-hand side as a tree.
For example, the following set of productions:
*/

Grammar{
    GrammarNonterminal ElementContent;
    GrammarAnnotation EventCode;
    lhs{ElementContent;};
        rhs{EE;EventCode(0);};
        rhs{SE(_*_); ElementContent;EventCode(1,0);};
        rhs{CH;ElementContent;EventCode(1,1);};
        rhs{ER;ElementContent;EventCode(1,2);};
        rhs{CM;ElementContent;EventCode(1,3,0);};
        rhs{PI;Elementcontent;EventCode(1,3,2);};
};

/*
represents a set of informationm items that might occur as element content after the start tag. Using the production event codes, we can visualize this set of productions as follows:
*/

figure{
    Tree(
        Leaf(EE,0),
        Tree(
            Leaf(SE(_*_),0),
            Leaf(CH,1),
            Leaf(ER,2),
            Tree(
                Leaf(CM,0),
                Leaf(PI,1),
                3
            )            
            , 1)
    );
    caption{"Event code tree for ElementContent grammar";};
};

/*

where the terminal symbols are represented by the leaf nodes of the tree, and the event code of each production rule defines a path from the root of the tree
to the node that represents the terminal symbol that is on the right-hand side of the production. We call this the event code tree for a given set of productions.

An event code tree is similar to a Huffman tree in that shorter paths are generally used for symbols that are considered more likely. However, event code
trees are far simpler and less costly to compute and maintain. Event code trees are shallow and contain at most three levels. In addition, the length of ech event code
in the event code tree is assigned statically without analyzing the data. This classification provides some of the benefits of a Huffman tree without the cost.
*/



label __8__3_Pruning title="8.3 Pruning Unneeded Productions";

/*

As discussed in section [6.3 Fidelity Options], applications MAY provide a set of fidelity options to specify the XML features they require. 
EXI processors MUST use thesefidelity options to prune the productions of which the terminal symbols represent the events that are not required from the grammars,
improving compactness and processing efficiency. For example, the following set of productions represent the set of information items that might occur as element
content after the start tag.

*/

example{
    label __8__6_Example_Fidelity title="Example 8-6. Example productions with full fidelity";
    Grammar{
        GrammarNonterminal ElementContent;
        lhs{ElementContent;};
            rhs{EE;ElementContent;EventCode(0);};
            rhs{SE(_*_);ElementContent;EventCode(1,0);};
            rhs{CH;ElementContent;EventCode(1,1);};
            rhs{ER;ElementContent;EventCode(1,2);};
            rhs{CM;ElementContent;EventCode(1,3,0);};
            rhs{PI;ElementContent;EventCode(1,3,1);};
    };
};

/*

If an application sets the fidelity options Preserve.Comments, Preserve.pis and Preserve.dtd to false, the productionsmatching comment (CM), 
processing instruction (PI) and entity reference (ER) events are pruned frm the grammar, producing the following set of productions:

*/

example{
    label __8__7_Example_Fidelity_After_Pruning title="Example 8-7. Example productions after pruning";
    GrammarNonterminal ElementCount;
    lhs{ElementCount;};
        rhs{EE;ElementCount;EventCode(0);};
        rhs{SE(_*_);ElementCount;EventCode(1,0);};
        rhs{CH;ElementCount;EventCode(1,1);};
};

/* 

Removing these productions from the grammar tells EXI processors that comments and processing instructions will never occur in the EXI stream, 
which reduces the entropy of the stream allowing it to be encoded in fewer bits.

Each time a production is removed from a grammar, the event codes of the other productions with the same nonterminal symbol on the left-hand side MUST be
adjusted to keep them contguous if its removal has left the remaining productions with non-contiguous event codes.

*/




